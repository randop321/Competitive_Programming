# Codeforces Worklog
|  ID   | Prob  | Sol | Feelings| 
|  ----  | ----  | ---- | ---- |
| 504E  | 给定一棵树，节点有字母，一条路径表示一个字符串。每次查询两条路径代表的字符串的LCP| Hash, 树链<br/>树上查询k级祖先<br/>二分答案，hash预处理前缀，将路径转化为两条链，问题转化为求树上的k级祖先。学习了一下O(1)的做法，但最后还是写了个重链剖分，之后2的幂次往上跳，单词查询复杂度O(lnlnN) |:monocle_face:  |
| 512D  | 给定一个无向图，每次可以删掉一个度数<2的点，问删掉k个点的不同方案数有几种，顺序不同也算不同 | 计数<br/> 有点小麻烦的计数，找出图中所有的树（或者长在某个环上的），这些才是最后有可能删除的点。然后就是dp了，对每棵树，为了避免重复计算，强制枚举下最后一个删除的点作为根节点（如果是长在别的环上就没必要了），最后复杂度n^3或者n^4都差不多| :hushed:	|
